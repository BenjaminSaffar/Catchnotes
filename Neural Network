import numpy as np


def sigmoid_prime(z):
    return sigmoid(z) * (1 - sigmoid(z))


def sigmoid(z):
    return 1 / (1 + np.exp(-z))


class Layer:
    def __init__(self, dim, input_size):
        self.dim = dim
        self.input_size = input_size
        self.weights = np.random.randn(dim, input_size)
        self.biases = np.random.randn(dim)
        self.z = np.array([], float)
        self.a = np.array([], float)

    def output(self, data):
        self.z = np.dot(self.weights, data) + self.biases
        return self.z

    def forward(self, data):
        self.a = sigmoid(self.output(data))
        return self.a

    def majweight(self, grad, rate, i, j):
        self.weights[i, j] -= rate * grad

    def majbiase(self, grad, rate):
        self.biases -= rate * grad


class Network:

    def __init__(self, input_dim):
        self.layers = []
        self.input_dim = input_dim

    def propagation(self, input_data):
        activation = input_data
        for layer in self.layers:
            activation = layer.forward(activation)
        return activation

    def add_layer(self, size):
        if len(self.layers) > 0:
            input_dim = self.layers[-1].dim
        else:
            input_dim = self.input_dim

        self.layers.append(Layer(size, input_dim))

    def train(self, data, exemple, rate):

        deltas = []
        delta = self.output_delta(data, exemple)
        deltas.append(delta)

        nb_layers = len(self.layers)
        for l in reversed(range(nb_layers - 1)):
            layer = self.layers[l]
            next_layer = self.layers[l + 1]
            delta = sigmoid_prime(layer.z) * np.dot(next_layer.weights.transpose(), delta)
            deltas.append(delta)

        deltas = list(reversed(deltas))

        for layer in self.layers:
            index = self.layers.index(layer)
            prc_layer = None
            if index > 0:
                prc_layer = self.layers[index - 1]
            for j in range(layer.dim-1):
                for k in range(layer.input_size):
                    if index == 0:
                        layer.majweight(data[k] * deltas[index][j], rate, j, k)
                    else:
                        layer.majweight(prc_layer.a[k] * deltas[index][j], rate, j, k)
                layer.majbiase(deltas[index], rate)

    def output_delta(self, data, target):
        out = self.propagation(data)
        return out-target






if __name__ == '__main__':
    data = np.array([0, 0], float)
    data_1 = np.array([0, 1], float)
    data_2 = np.array([1, 0], float)
    data_3 = np.array([1, 1], float)

    exemple = np.array([1, 1])
    exemple_1 = np.array([1, 0])
    exemple_2 = np.array([0, 1])
    exemple_3 = np.array([0, 0])

    net = Network(2)
    net.add_layer(10)
    net.add_layer(2)

    train_rate = 0.9

    print(net.propagation(data))
    print(net.propagation(data_1))
    print(net.propagation(data_2))
    print(net.propagation(data_3))

    for i in range(1, 10000):
        net.train(data, exemple, train_rate)
        net.train(data_1, exemple_1, train_rate)
        net.train(data_2, exemple_2, train_rate)
        net.train(data_3, exemple_3, train_rate)

    print("\n")
    print(net.propagation(data))
    print(net.propagation(data_1))
    print(net.propagation(data_2))
    print(net.propagation(data_3))



